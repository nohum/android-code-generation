/**
 * generated by Xtext
 */
package at.fhj.gaar.androidapp.validation;

import at.fhj.gaar.androidapp.appDsl.ActionStartActivity;
import at.fhj.gaar.androidapp.appDsl.ActionStartService;
import at.fhj.gaar.androidapp.appDsl.Activity;
import at.fhj.gaar.androidapp.appDsl.ActivityLayoutAttribute;
import at.fhj.gaar.androidapp.appDsl.AppDslPackage;
import at.fhj.gaar.androidapp.appDsl.Application;
import at.fhj.gaar.androidapp.appDsl.ApplicationElement;
import at.fhj.gaar.androidapp.appDsl.ApplicationElementList;
import at.fhj.gaar.androidapp.appDsl.ApplicationMainActivity;
import at.fhj.gaar.androidapp.appDsl.ApplicationPermissionList;
import at.fhj.gaar.androidapp.appDsl.Button;
import at.fhj.gaar.androidapp.appDsl.ElementIntentList;
import at.fhj.gaar.androidapp.appDsl.LayoutElement;
import at.fhj.gaar.androidapp.validation.AbstractAppDslValidator;
import java.util.ArrayList;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;
import org.eclipse.emf.common.util.EList;
import org.eclipse.xtext.validation.Check;
import org.eclipse.xtext.xbase.lib.Conversions;

/**
 * Custom validation rules.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 */
@SuppressWarnings("all")
public class AppDslValidator extends AbstractAppDslValidator {
  @Check
  public void checkCompileSdkBounds(final Application application) {
  }
  
  public void checkTargetSdkBounds(final Application application) {
  }
  
  @Check
  public void checkForValidMainActivity(final ApplicationMainActivity mainActivity, final ApplicationElementList elements) {
    Logger _logger = Logger.getLogger("");
    _logger.log(Level.SEVERE, "checkForValidMainActivity");
    boolean _or = false;
    EList<ApplicationElement> _elements = elements.getElements();
    int _length = ((Object[])Conversions.unwrapArray(_elements, Object.class)).length;
    boolean _equals = (_length == 0);
    if (_equals) {
      _or = true;
    } else {
      String _launcherActivity = mainActivity.getLauncherActivity();
      int _length_1 = _launcherActivity.length();
      boolean _equals_1 = (_length_1 == 0);
      _or = _equals_1;
    }
    if (_or) {
      return;
    }
    EList<ApplicationElement> _elements_1 = elements.getElements();
    for (final ApplicationElement element : _elements_1) {
      boolean _and = false;
      if (!(element instanceof Activity)) {
        _and = false;
      } else {
        String _className = element.getClassName();
        String _launcherActivity_1 = mainActivity.getLauncherActivity();
        boolean _equals_2 = _className.equals(_launcherActivity_1);
        _and = _equals_2;
      }
      if (_and) {
        return;
      }
    }
    String _launcherActivity_2 = mainActivity.getLauncherActivity();
    String _format = String.format("Activity with identifier \"%s\" is unknown", _launcherActivity_2);
    this.error(_format, 
      AppDslPackage.Literals.APPLICATION_MAIN_ACTIVITY__LAUNCHER_ACTIVITY);
  }
  
  @Check
  public void checkForDuplicatePermission(final ApplicationPermissionList permissions) {
    List<String> foundPermissions = new ArrayList<String>();
    int listIndex = 0;
    EList<String> _permissions = permissions.getPermissions();
    for (final String permission : _permissions) {
      {
        boolean _contains = foundPermissions.contains(permission);
        if (_contains) {
          this.error("Permissions have to be unique", AppDslPackage.Literals.APPLICATION_PERMISSION_LIST__PERMISSIONS, listIndex);
        }
        foundPermissions.add(permission);
        listIndex++;
      }
    }
  }
  
  @Check
  public void checkForDuplicateIntent(final ElementIntentList intents) {
    List<String> foundIntents = new ArrayList<String>();
    int listIndex = 0;
    EList<String> _intents = intents.getIntents();
    for (final String intent : _intents) {
      {
        boolean _contains = foundIntents.contains(intent);
        if (_contains) {
          this.error("Intents have to be unique", AppDslPackage.Literals.ELEMENT_INTENT_LIST__INTENTS, listIndex);
        }
        foundIntents.add(intent);
        listIndex++;
      }
    }
  }
  
  @Check
  public void checkForDuplicateElementIdentifier(final ApplicationElementList elements) {
    List<String> foundElementNames = new ArrayList<String>();
    EList<ApplicationElement> _elements = elements.getElements();
    for (final ApplicationElement element : _elements) {
      {
        String _className = element.getClassName();
        boolean _contains = foundElementNames.contains(_className);
        if (_contains) {
          String _className_1 = element.getClassName();
          String _format = String.format("Identifier \"%s\" has already been used", _className_1);
          this.error(_format, element, 
            AppDslPackage.Literals.APPLICATION_ELEMENT__CLASS_NAME);
        }
        String _className_2 = element.getClassName();
        foundElementNames.add(_className_2);
      }
    }
  }
  
  @Check
  public void checkForDuplicateButtonIdentifier(final ActivityLayoutAttribute layoutElements) {
    List<String> foundNames = new ArrayList<String>();
    EList<LayoutElement> _layoutElements = layoutElements.getLayoutElements();
    for (final LayoutElement element : _layoutElements) {
      if ((element instanceof Button)) {
        String buttonName = ((Button) element).getButtonName();
        boolean _contains = foundNames.contains(buttonName);
        if (_contains) {
          String _format = String.format("Button name \"%s\" is not unique", buttonName);
          this.error(_format, element, 
            AppDslPackage.Literals.BUTTON__BUTTON_NAME);
        }
        foundNames.add(buttonName);
      }
    }
  }
  
  @Check
  public void checkForValidActionStartActivity(final ActionStartActivity startActivity) {
  }
  
  @Check
  public void checkForValidActionStartService(final ActionStartService startService) {
  }
}
